http协议，超文本传输，最初用来做超文本的请求和响应，无状态，简单
比如请求http://host:/user.html 服务器找到资源返回即可，马上断开tcp连接  客户端拿到html可以
再通过里面的链接请求新的.html文档，这样链来链去就是超级文本。

但是贪婪的人类不在满足这个简单的需求，他们要求http能够支持他们更加复杂的需求
1，他们不满足单纯的接受服务端内容，他们需要自己制造内容，于是表单和文件上传被加进来
2，他们不满足网页只是简单的内容加链接，于是dom+js被加进来
3，他们希望服务端知道用户的行为，于是cookie被加进来,这样可简单的维护客户端的状态
4，要服务于上面的需求，服务端加了jsp,php,cgi等编程性技术

session技术的诞生，解决http的无状态，服务器为每个用户维护一个空间，让用户在这个空间中保存自己的状态
其实要解决状态这个东西，有几个方法：
1，协议本身来支持，但是http不支持，所以不讨论
2，客户端自己维护，所有的状态全部由客户端自己提供，REST概念就是讨论这个 如果服务端没有状态，对于架构上可以简化很多问题
3，服务端维护用户的状态，但是需要用户有一个标识来找到服务端的那个状态

第2种可以用cookie来实现,但是cookie本身容量有限
第3中可以借助第2种的cookie机制，存储客户的标识，当然不是必须要用cookie

cookie机制：
服务端分发，在http响应头中，不过客户端脚本js也可以在客户端写入cookie,cookie的元素有下面几个
1，key,value
2,域+路径
3，过期时间
如果不设定过期时间，则浏览器会将cookie维护在当前进程的内存中,如果浏览器关闭就消失,如果设置了过期时间，浏览器就要借助
永久磁盘来保存这个cookie，然后在启动浏览器访问cookie所服务的网站的时候送过去

浏览器窗口的行为和浏览器本身的技术会影响cookie的发送，有时候共享，有时候不共享，浏览器对于会话cookie的这种只认cookie不认人的处理方式经常给采用session机制的web应用程序开发者造成很大的困扰。

session机制：
一种服务端机制，为客户端维护一个类似散列表的数据结构，然后根据客户的标识去查找客户端的状态空间
当程序需要为某个客户端的请求创建一个session的时候，服务器首先检查这个客户端的请求里是否已包含了一个session标识 - 称为 session id，如果已包含一个session id则说明以前已经为此客户端创建过session
服务器就按照session id把这个 session检索出来使用（如果检索不到，可能会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个 session id将被在本次响应中返回给客户端保存。

保存这个session id可以有多种方法
1，利用cookie，缺点是如果客户端禁止写cookie则不生效
2，url重写，服务端发给浏览器的时候在链接上加上session id的值
3，表单隐藏字段，服务端修改网页的表单，加入一个隐藏域 (已经很少使用）可以完全通过第2种来实现

注意：服务端在session过期之前销毁session，浏览器的关闭也不会使服务端的session销毁，要使session销毁只有两种办法：
1，手动的session.invalidate
2，过期之后服务端销毁session
3，session维护在服务器内存中，服务器崩溃,有些服务器会把session钝化到硬盘或者集群来放置session爆棚的情况
不过在浏览器关闭的时候可以设定一个事件去通知服务端销毁session，但是对于浏览器被强行杀死和崩溃的情况，这种方法也没有作用

java平台的session 以tomcat为例
session是在HttpServletRequest.getSession（true）时创建
第一次请求Set-Cookie	JSESSIONID=9531DDC317BA42F20325F0D8DE97DC56; Path=/workflow/; HttpOnly
HttpOnly告诉浏览器，这个cookie客户端脚本不可访问
随后的请求 Cookie	JSESSIONID=9531DDC317BA42F20325F0D8DE97DC56

tomcat将cookie设置在应用的路径下，这样有效的隔离了不同应用的cookie共享,但是weblogic这种服务器是设置在根域名同时也避免了共享

跨应用的session共享
sevlet规范中，session的作用范围仅仅限于当前应用，对于不同应用共享session的需求需要三方解决方案

session机制本身并不复杂，然而其实现和配置上的灵活性却使得具体情况复杂多变。这也要求我们不能把仅仅某一次的经验或者某一个浏览器，服务器的经验当作普遍适用的经验，而是始终需要具体情况具体分析。
为此我们在项目中编写了一个session框架，用它来重写规范中的一些行为来解决项目中的一些问题。

服务器一般对session做一些钝化处理，不同服务器实现不同，而我们的session框架使用memcache来进行集群管理
对于状态分为两种，一种是cookie，一种就是memcahe的缓存

所有的保存无论是cookie还是session都是通过request.getSession().setAttribute
保存到cookie中的是一些简单文本数据，可设置生命周期，比如购物车的跟踪cookie

保存到session中是可序列化的复杂对象，它的生命周期由session决定，通过配置session的过期时间，session是否过期是通过一个用户的最后访问时间和当前时间做计算得到的

所以在做数据保存的时候要明白这几个概念：
1，是否是session数据，loginUser，验证码这些都是session数据
2，是否是大对象，因为cookie不能保存大对象
3,生命周期 如果要浏览器关闭就失效，那必须是cookie同时是文本型数据，如果是长时间保存也必须是cookie，保存在session中的数据有个过期时间


